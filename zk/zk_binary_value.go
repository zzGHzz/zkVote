// Prove v\in{0,1} given g^a, ((g^k)^a)(g^v)
// 	a 		- a known secret key
//	g^k 	- a known public key

package zk

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"math/big"

	"github.com/zzGHzz/zkVote/common"
)

// BinaryProver - structure
type BinaryProver struct {
	curve elliptic.Curve
	value bool              // binary cast value
	a     *ecdsa.PrivateKey // private key generated by voter for voting
	gk    *ecdsa.PublicKey  // public key shared by authority
}

// BinaryProof - structure
type BinaryProof struct {
	data               []byte
	yX, yY             *big.Int // y = g^{ka}
	d1, r1             *big.Int
	d2, r2             *big.Int
	a1X, a1Y, b1X, b1Y *big.Int
	a2X, a2Y, b2X, b2Y *big.Int
}

// NewBinaryProver - new Prover
func NewBinaryProver(value bool, a *ecdsa.PrivateKey, gk *ecdsa.PublicKey) (*BinaryProver, error) {
	if gk == nil {
		return nil, errors.New("gk cannot be nil")
	}

	if !gk.Curve.IsOnCurve(gk.X, gk.Y) {
		return nil, ErrInvalidPub
	}

	if a == nil {
		var err error
		a, err = ecdsa.GenerateKey(gk.Curve, rand.Reader)
		if err != nil {
			return nil, err
		}
	} else {
		if a.PublicKey.Curve != gk.Curve {
			return nil, ErrCurveNotMatch
		}

		if a.D.Cmp(a.PublicKey.Curve.Params().N) >= 0 || a.D.Cmp(big.NewInt(1)) == -1 {
			return nil, ErrInvalidPriv
		}
	}

	return &BinaryProver{gk.Curve, value, a, gk}, nil
}

// Prove generates the zk proof of a binary value
//
// data - used to identify the prover, e.g., his/her account address
func (p *BinaryProver) Prove(data []byte) (*BinaryProof, error) {
	N := new(big.Int).Set(p.curve.Params().N) // order of G

	var w, r1, r2, d1, d2 *big.Int
	var yX, yY *big.Int
	var a1X, a1Y, b1X, b1Y, a2X, a2Y, b2X, b2Y *big.Int

	var err error

	if w, err = randq(N); err != nil {
		return nil, err
	}
	wX, wY := p.curve.ScalarBaseMult(w.Bytes())

	var X1, Y1, X2, Y2, X3, Y3 *big.Int
	if !p.value {
		if r2, err = ecrand(p.curve); err != nil {
			return nil, err
		}
		if d2, err = ecrand(p.curve); err != nil {
			return nil, err
		}

		// y = g^{k*a}
		yX, yY = p.curve.ScalarMult(p.gk.X, p.gk.Y, p.a.D.Bytes())

		// a1 = g^w
		a1X, a1Y = wX, wY

		// b1 = g^{kw}
		b1X, b1Y = p.curve.ScalarMult(p.gk.X, p.gk.Y, w.Bytes())

		// a2 = g^{r2 + d2*a}
		X1, Y1 = p.curve.ScalarBaseMult(r2.Bytes())
		X2, Y2 = p.curve.ScalarMult(p.a.PublicKey.X, p.a.PublicKey.Y, d2.Bytes())
		a2X, a2Y = p.curve.Add(X1, Y1, X2, Y2)

		// g^{d2*k*a} = (g^{k*a})^{d2}
		X1, Y1 = p.curve.ScalarMult(yX, yY, d2.Bytes())
		// g^{k*r2} = (g^k)^r2
		X2, Y2 = p.curve.ScalarMult(p.gk.X, p.gk.Y, r2.Bytes())
		// g^{-d2}
		X3, Y3 = p.curve.ScalarBaseMult(new(big.Int).Sub(N, d2).Bytes())
		// b2 = g^{d2*k*a + k*r2 - d2}
		b2X, b2Y = p.curve.Add(X1, Y1, X2, Y2)
		b2X, b2Y = p.curve.Add(b2X, b2Y, X3, Y3)

		// c = hash(data, g^a, y, a1, b1, a2, b2)
		c := sha256.Sum256(common.ConcatBytesTight(
			data,
			p.a.PublicKey.X.Bytes(), p.a.PublicKey.Y.Bytes(),
			yX.Bytes(), yY.Bytes(),
			a1X.Bytes(), a1Y.Bytes(),
			b1X.Bytes(), b1Y.Bytes(),
			a2X.Bytes(), a2Y.Bytes(),
			b2X.Bytes(), b2Y.Bytes(),
		))
		// fmt.Printf("%x\n", c)

		// d1 = c - d2
		d1 = new(big.Int).SetBytes(c[:])
		d1 = d1.Sub(d1, d2)
		d1 = d1.Mod(d1, N)

		// r1 = w - d1*a
		r1 = new(big.Int).Mul(d1, p.a.D)
		r1 = r1.Sub(w, r1)
		r1 = r1.Mod(r1, N)
	} else {
		if r1, err = ecrand(p.curve); err != nil {
			return nil, err
		}
		if d1, err = ecrand(p.curve); err != nil {
			return nil, err
		}

		// y = g^{ka+1}
		yX, yY = p.curve.ScalarMult(p.gk.X, p.gk.Y, p.a.D.Bytes())
		yX, yY = p.curve.Add(yX, yY, p.curve.Params().Gx, p.curve.Params().Gy)

		// a2 = g^w
		a2X, a2Y = wX, wY

		// b2 = g^{kw}
		b2X, b2Y = p.curve.ScalarMult(p.gk.X, p.gk.Y, w.Bytes())

		// a1 = g^{r1 + d1*a}
		X1, Y1 = p.curve.ScalarBaseMult(r1.Bytes())
		X2, Y2 = p.curve.ScalarMult(p.a.PublicKey.X, p.a.PublicKey.Y, d1.Bytes())
		a1X, a1Y = p.curve.Add(X1, Y1, X2, Y2)

		// g^{d1*k*a+d1} = y^d1
		X1, Y1 = p.curve.ScalarMult(yX, yY, d1.Bytes())
		// g^{k*r1} = (g^k)^r1
		X2, Y2 = p.curve.ScalarMult(p.gk.X, p.gk.Y, r1.Bytes())
		// b1 = g^{d1*k*a + k*r1 + d1} = y^d1 g^{k*r1}
		b1X, b1Y = p.curve.Add(X1, Y1, X2, Y2)

		// c = hash(data, g^a, y, a1, b1, a2, b2)
		c := sha256.Sum256(common.ConcatBytesTight(
			data,
			p.a.PublicKey.X.Bytes(), p.a.PublicKey.Y.Bytes(),
			yX.Bytes(), yY.Bytes(),
			a1X.Bytes(), a1Y.Bytes(),
			b1X.Bytes(), b1Y.Bytes(),
			a2X.Bytes(), a2Y.Bytes(),
			b2X.Bytes(), b2Y.Bytes(),
		))

		// d2 = c - d1
		d2 = new(big.Int).SetBytes(c[:])
		d2 = d2.Sub(d2, d1)
		d2 = d2.Mod(d2, N)

		// r2 = w - d2*a
		r2 = new(big.Int).Mul(d2, p.a.D)
		r2 = r2.Sub(w, r2)
		r2 = r2.Mod(r2, N)
	}

	return &BinaryProof{
		append([]byte(nil), data...),
		yX, yY,
		d1, r1, d2, r2,
		a1X, a1Y, b1X, b1Y,
		a2X, a2Y, b2X, b2Y}, nil
}

// Validate checks the validity of the zk proof
func (p *BinaryProof) Validate(curve elliptic.Curve) error {
	// r1, r2, d1, d2 \in [1, N-1]
	if p.r1.Cmp(big.NewInt(1)) < 0 || p.r1.Cmp(curve.Params().N) >= 0 ||
		p.r2.Cmp(big.NewInt(1)) < 0 || p.r2.Cmp(curve.Params().N) >= 0 ||
		p.d1.Cmp(big.NewInt(1)) < 0 || p.d1.Cmp(curve.Params().N) >= 0 ||
		p.d2.Cmp(big.NewInt(1)) < 0 || p.d2.Cmp(curve.Params().N) >= 0 {
		return ErrOutOfRange
	}

	// a1, a2, b1, b2 must on curve
	if !curve.IsOnCurve(p.a1X, p.a1Y) ||
		!curve.IsOnCurve(p.a2X, p.a2Y) ||
		!curve.IsOnCurve(p.b1X, p.b1Y) ||
		!curve.IsOnCurve(p.b2X, p.b2Y) {
		return ErrNotOnCurve
	}

	return nil
}

// Verify verifies the zk proof of the binary value
//
// p 	- zk proof
// pa 	- voter's public key generated for the binary value
// pk 	- authority's public key
// N 	- order of the generator of the ellipic curve
func (p *BinaryProof) Verify(pa *ecdsa.PublicKey, pk *ecdsa.PublicKey) (bool, error) {
	if err := p.Validate(pa.Curve); err != nil {
		return false, nil
	}

	if pa.Curve != pk.Curve {
		return false, ErrCurveNotMatch
	}

	curve := pa.Curve
	if !curve.IsOnCurve(pa.X, pa.Y) || !curve.IsOnCurve(pk.X, pk.Y) {
		return false, ErrInvalidPub
	}

	N := new(big.Int).Set(curve.Params().N)

	// d1 + d2 == c mod N
	c := sha256.Sum256(common.ConcatBytesTight(
		p.data,
		pa.X.Bytes(), pa.Y.Bytes(),
		p.yX.Bytes(), p.yY.Bytes(),
		p.a1X.Bytes(), p.a1Y.Bytes(),
		p.b1X.Bytes(), p.b1Y.Bytes(),
		p.a2X.Bytes(), p.a2Y.Bytes(),
		p.b2X.Bytes(), p.b2Y.Bytes(),
	))
	// fmt.Printf("%x\n", c)

	x := new(big.Int).Add(p.d1, p.d2)
	x = x.Mod(x, N)
	y := new(big.Int).SetBytes(c[:])
	y = y.Mod(y, N)
	if x.Cmp(y) != 0 {
		return false, nil
	}

	var X, Y, X1, Y1, X2, Y2, X3, Y3 *big.Int

	// a1 = g^{r1 + d1*a}
	X1, Y1 = curve.ScalarBaseMult(p.r1.Bytes())
	X2, Y2 = curve.ScalarMult(pa.X, pa.Y, p.d1.Bytes())
	X, Y = curve.Add(X1, Y1, X2, Y2)
	if p.a1X.Cmp(X) != 0 || p.a1Y.Cmp(Y) != 0 {
		return false, nil
	}

	// b1 = g^{k*r1} y^d1
	X1, Y1 = curve.ScalarMult(pk.X, pk.Y, p.r1.Bytes())
	X2, Y2 = curve.ScalarMult(p.yX, p.yY, p.d1.Bytes())
	X, Y = curve.Add(X1, Y1, X2, Y2)
	if p.b1X.Cmp(X) != 0 || p.b1Y.Cmp(Y) != 0 {
		return false, nil
	}

	// a2 = g^{r2 + d2*a}
	X1, Y1 = curve.ScalarBaseMult(p.r2.Bytes())
	X2, Y2 = curve.ScalarMult(pa.X, pa.Y, p.d2.Bytes())
	X, Y = curve.Add(X1, Y1, X2, Y2)
	if p.a2X.Cmp(X) != 0 || p.a2Y.Cmp(Y) != 0 {
		return false, nil
	}

	// b2 = g^{k*r2} (y/g)^d2
	X1, Y1 = curve.ScalarMult(pk.X, pk.Y, p.r2.Bytes())
	X2, Y2 = curve.ScalarMult(p.yX, p.yY, p.d2.Bytes())
	X3, Y3 = curve.ScalarBaseMult(new(big.Int).Sub(N, p.d2).Bytes())
	X, Y = curve.Add(X1, Y1, X2, Y2)
	X, Y = curve.Add(X, Y, X3, Y3)
	if p.b2X.Cmp(X) != 0 || p.b2Y.Cmp(Y) != 0 {
		return false, nil
	}

	return true, nil
}
